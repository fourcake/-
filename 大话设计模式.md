# 大话设计模式

## 基础	面向对象特性

1. 面向对象好处：**可维护、可复用、可扩展、灵活性好**

2. 封装：**每个对象都包含它能进行操作所需要的所有信息，因此对象不必依赖其它对象来完成自己的操作。**这样方法和属性包装在类里面，通过类的实例来实现操作。优点在于：1.减少耦合 2.类内部可以自由更改不影响外部 3.类具有清晰的对外接口

3. 继承：**子类继承父类，**子类拥有父类非private的属性和方法（protect修饰类成员，对于类公开，对其他类不公开）、子类具有自己的属性和功能、子类可以以自己的方式实现父类功能（方法重写）。优点在于：继承使得所有子类公共部分都放在父类，使得代码共享，避免重复，但继承会增大两个类之间耦合性

4. 多态：当方法被调用时，无论对象是否被转换为其父类，都只有位于对象继承链最末端的方法实现会被调用，也就是说，**虚方法是按运行时类型而非编译时类型进行动态绑定调用的**

   ```java
   动物 animal = new 猫();
   ```

## 第一章	简单工厂模式

1. 代码规范：命名规范、多个连续if判断条件时应该用switch-case替换，避免无用的判断、考虑边界条件

2. 思想：将抽象、封装、继承、多态后的**代码转变为实例化对象的问题，**即到底要实例化谁的问题。之后只要输入满足指定的条件，工厂就会实例化出合适的对象，通过多态，返回父类的方式实现需求

3. 优点：工厂类包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了类与具体产品的依赖

4. 缺点：工厂里面是一个选择分支语句，每增加一个类，都要相应的修改工厂类增加分支语句，所以简单工厂模式不符合开放-封闭原则

5. 代码示例：简单工厂模式

   ![image-20220905144915932](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144915932.png)

   ```java
   package simple_cuclate_factory;
   //Operation.calss
   public class Operation {
       private double _numberA = 0;
       private double _numberB = 0;
   
       public double get_numberA() {
           return _numberA;
       }
   
       public void set_numberA(double _numberA) {
           this._numberA = _numberA;
       }
   
       public double get_numberB() {
           return _numberB;
       }
   
       public void set_numberB(double _numberB) {
           this._numberB = _numberB;
       }
   
   
       /// <summary>
       /// 得到运算结果
       /// </summary>
       /// <returns></returns>
       public double GetResult()
       {
           double result = 0;
           return result;
       }
   
       /// <summary>
       /// 检查输入的字符串是否准确
       /// </summary>
       public static String checkNumberInput(String currentNumber, String inputString)
       {
           String result = "";
           if (inputString == ".")
           {
               if (currentNumber.indexOf(".") < 0)
               {
                   if (currentNumber.length() == 0)
                       result = "0" + inputString;
                   else
                       result = currentNumber + inputString;
               }
           }
           else if (currentNumber == "0")
           {
               result = inputString;
           }
           else
           {
               result = currentNumber + inputString;
           }
   
           return result;
       }
   
   }
   
   /// <summary>
   /// 加法类
   /// </summary>
   class OperationAdd extends Operation
   {
       @Override
       public  double GetResult()
       {
           double result = 0;
           result = this.get_numberA() + this.get_numberB();
           return result;
       }
   }
   
   //OperationFactory.class
   public class OperationFactory {
   
       public static Operation createOperate(String operate)
       {
           Operation oper = null;
           switch (operate)
           {
               case "+":
               {
                   oper = new OperationAdd();
                   break;
               }
   
           }
           return oper;
       }
   }
   //test.class
   import javax.sound.midi.SysexMessage;
   
   public class test {
       public static void main(String[] args) throws Exception {
           Operation oper=new Operation();
           oper=OperationFactory.createOperate("+");
           oper.set_numberA(4);
           oper.set_numberB(8);
           double result=0;
           result = oper.GetResult();
           System.out.println(result);
       }
   }
   ```

   

## 第二章 策略模式

首先，回顾工厂模式，实现商场打折收费代码

```java
package simple_charges_pattern;

public abstract class CashSuper {
    public abstract double acceprCash(double money);
}
//正常收费
class cashNormal extends CashSuper{
    @Override
    public double acceprCash(double money) {
        return money;
    }
}
//打折收费
class cashDebate extends CashSuper{
    private double moneyRebate=1.0;

    public cashDebate(double moneyRebate) {
        this.moneyRebate = moneyRebate;
    }

    @Override
    public double acceprCash(double money) {

        return money*moneyRebate;
    }
}
//返利收费
class cashReturn extends CashSuper{
    private double moneyReturn=0.0;
    private double moneyCondition;

    public cashReturn(double moneyCondition,double moneyReturn) {
        this.moneyReturn = moneyReturn;
        this.moneyCondition=moneyCondition;
    }

    @Override
    public double acceprCash(double money) {
        double result =money;
        if(money>moneyCondition){
            result=money-(money/moneyCondition)*moneyReturn;
        }
        return result;
    }
}
```

```java
package simple_charges_pattern;

public class CashFactory {
    public static CashSuper createCashACccept(String type){
        CashSuper cs=null;
        switch (type){
            case "正常收费":
                cs=new cashNormal();
                break;
            case "满300返100":
                cashReturn cr1=new cashReturn(300,100);
                cs=cr1;
                break;
            case "打八折":
                cashDebate cr2=new cashDebate(0.8);
                cs=cr2;
                break;
        }

        return cs;
    }
}
```

```java
package simple_charges_pattern;

public class test {
    public static void main(String[] args) throws Exception {
        CashSuper csuper=CashFactory.createCashACccept("打八折");
        double totalPrice=0;
        totalPrice=csuper.acceprCash(1000);
        System.out.println(totalPrice);
    }
}
```

简单工厂模式只是解决对象的创建问题，但是商场可能随时更改打折活动，每次维护或者扩展都要改动这个工厂，以致代码需要重新编译部署，这很糟糕，面对算法的时常变动，应该有更好的方法，这就是**策略模式**。

![image-20220905144957231](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144957231.png)

策略模式定义了算法家族，分别封装起来，**让他们可以互相替换，**此模式让算法的变化不会影响到使用算法的客户

策略+简单工厂模式实现如下：（CashSuper文件不用变）

![image-20220905145011985](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905145011985.png)

```java
package strategy_pattern;

public class CashContext {
    private CashSuper cs;

    public CashContext(String mode) {
        switch (mode){
            case "正常收费":
                cs=new cashNormal();
                break;
            case "满300返100":
                cs=new cashReturn(300,100);
                break;
            case "打八折":
                cs=new cashDebate(0.8);
                break;
            }
    }
    public double GetResult(double money){
        return cs.acceprCash(money);
    }
}
```

```Java
package strategy_pattern;

public class test {
    public static void main(String[] args) throws Exception {
        String mode = "满300返100";
        CashContext cc=new CashContext(mode);
        double result=0;
        double originalFee=1000;

        result= cc.GetResult(originalFee);
        System.out.println(result);
    }
}
```

将策略模式融入后，有诸多好处：

1. 客户端简单明了。原来客户端需要认识两个类，工厂类（CashFactory）和方法类（CashSuper），现在客户端只需要认识CashContext类即可，使得具体收费算法彻底与客户端分离，降低耦合。
2. 便于单元测试
3. 在客户端代码中避免了大量判断语句，这点很重要

策略模式是用来封装算法的，但在实践中，我们可以用它来封装几乎任何类型的规则，只要是需要在不同时间应用不同规则，就都可以这么考虑

## 第三章 原则

1. 单一职责原则：**就一个类而言，应该仅有一个引起它变化的原因。**如果一个类承担的职责过多，就等于把这些职责耦合在一起，当变化发生时，设计可能会遭受到意想不到的破坏。

2. 开闭原则：**即不能修改，但可以扩展的思想，对程序的变动是通过添加新代码产生的，而尽量不是修改源代码。**对于扩展是开放的，对于更改是封闭的。可以最初编写代码时假设变化不会发生，当变化发生时，就创建抽象来隔离以后可能发生的同类变化

3. 里氏代换原则：子类必须能够替换它的父类

4. 依赖倒转原则：抽象不应该依赖于细节，细节应该依赖于抽象；**高层模块不应依赖低层模块，两个都应依赖抽象。**其实就是**针对接口编程而不是针对实现编程。**

   ![image-20220905144747335](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144747335.png)

   ![image-20220905144804498](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144804498.png)

## 第四章 装饰模式

**动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更加灵活，有效的将类的核心职责和和装饰功能区分开**

![image-20220905144621303](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144621303.png)

举例1：给用户搭配衣服

![image-20220905144655780](images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144655780.png)

```java
package decorator_pattern;

public class Person {
    private String name;

    public Person(String name) {
        this.name = name;
    }

    public void show() {
        System.out.println("装扮的"+name);
    }
}
```

```java
package decorator_pattern;

class Decorator_Finery extends Person{
    protected Person component;
    public Decorator_Finery(String name) {
        super(name);
    }
    //打扮
    public void Decorate(Person component){
        this.component=component;
    }
    @Override
    public void show() {
        if(component!=null){
            component.show();
        }
    }
}
```

```java
package decorator_pattern;
//具体服饰类：ConcreteDecorator
class TShirts extends Decorator_Finery{
    public TShirts(String name) {
        super(name);
    }

    @Override
    public void show() {
        System.out.println("大T恤");
        super.show();
    }
}
class BigTourse extends Decorator_Finery{
    public BigTourse(String name) {
        super(name);
    }

    @Override
    public void show() {
        System.out.println("跨裤");
        super.show();
    }
}
class GoodShoes extends Decorator_Finery{

    public GoodShoes(String name) {
        super(name);
    }

    @Override
    public void show() {
        System.out.println("好球鞋");
        super.show();
    }
}
//还可以继续添加
```

```java
//客户端
package decorator_pattern;
public class test {
    public static void main(String strgs[]){
        String name="小菜";
        Person xc=new Person(name);
        System.out.println("第一种");
        GoodShoes gs=new GoodShoes(name);
        BigTourse bt=new BigTourse(name);
        TShirts ts=new TShirts(name);
        gs.Decorate(xc);
        bt.Decorate(gs);
        ts.Decorate(bt);
        ts.show();
    }
}
```

举例2：卖鸡蛋饼算账

<img src="images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220905144313189.png" alt="image-20220905144313189" style="zoom:80%;" />

```java
public abstract class Cake {
	abstract int cost();
}
```

```java
public class HandCake extends Cake {
	@Override
	int cost() {
		return 4;
	}
}
```

```java
public class Seasoning extends Cake {
	private Cake cake;
	Seasoning(Cake cake){
		this.cake=cake;
	}
	@Override
	int cost() {
		return cake.cost();
	}
}
```

```java
class Egg extends Seasoning {
	Egg(Cake cake) {
		super(cake);
	}
	int cost(){
		return super.cost()+2;
	}
}
class Ham extends Seasoning{
	Ham(Cake cake) {
		super(cake);
	}
	int cost(){
		return super.cost()+2;
	}
}
class Becon extends Seasoning {
	Becon(Cake cake) {
		super(cake);
	}
	int cost(){
		return super.cost()+2;
	}
}
```

```java
//客户端
public class Main {
	public static void main(String[] args) {
		Cake cake = new HandCake();
		System.out.println("手抓饼："+cake.cost());
		Egg egg = new Egg(cake);
		System.out.println("+1个鸡蛋："+egg.cost());
		Ham ham = new Ham(egg);
		System.out.println("+1片火腿："+ham.cost());
		Becon becon = new Becon(ham);
		System.out.println("+1份培根："+becon.cost());
		Egg egg2 = new Egg(becon);
		System.out.println("再+一个鸡蛋："+egg2.cost());
	}
}
```

## 第五章 代理模式 

1. 代理模式：为其他对象提供一种代理以控制对这个对象的访问。**其实就是在访问对象时，引入一定的间接性，这种间接性可以附加多种用途**

2. 应用于后面代追mm的例子，subject就是IGiveGift接口，是Proxy和RealSubject的共同方法，RealSubject就是Persuit追求者类，而Proxy则就是代理追求者行为的代理类。

   <img src="images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220907150026365.png" alt="image-20220907150026365" style="zoom:120%;" />

3. 应用场合：

   - 远程代理：为一个对象在不同的地址空间提供局部代表，这样即可隐藏一个对象存在于不同地址空间的事实。例子：WebService
   - 虚拟代理：**是根据需要创建开销很大的对象，通过它来存放实例化需要很长时间的真实对象。**这样可以达到性能的最优化，比如打开较大的HTML网站，先加载出的是文字，而没加载出来的图片框，就是通过虚拟代理代替了原本的图片
   - 安全代理：**用来控制真实对象的访问权限。**一般用于对象由不同的访问权限的时候
   - 智能指引：**指调用真实对象的时候，代理来处理另外一些事情。**即通过代理来在访问一个对象时附加一些内务处理（比如计对象引用数，不引用时自动释放、第一次引入一个持久对象时，将之装入内存等）。

4.  举例，代理追MM

<img src="images/%E5%A4%A7%E8%AF%9D%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/image-20220907152037720.png" alt="image-20220907152037720" style="zoom:80%;" />

```java
package proxy_pattern;
//Subject
public interface IGiveGift {
    void Give_Dolls();
    void Give_Flowers();
    void Give_Chocolate();
}
```

```java
package proxy_pattern;
//RealSubject
public class Persuit implements IGiveGift{
    SchoolGirls mm;
    public Persuit(SchoolGirls mm) {
        this.mm = mm;
    }
    @Override
    public void Give_Dolls() {
        System.out.println(mm.getName()+"送你洋娃娃");
    }
    @Override
    public void Give_Flowers() {
        System.out.println(mm.getName()+"送你花");
    }
    @Override
    public void Give_Chocolate() {
        System.out.println(mm.getName()+"送你巧克力");
    }
}
```

```java
package proxy_pattern;
//Proxy
public class Proxy implements IGiveGift{
    Persuit gg;
    public Proxy(SchoolGirls mm){
        gg=new Persuit(mm);
    }
    @Override
    public void Give_Dolls() {
        gg.Give_Dolls();
    }
    @Override
    public void Give_Flowers() {
        gg.Give_Flowers();
    }
    @Override
    public void Give_Chocolate() {
        gg.Give_Chocolate();
    }
}
```

```java
package proxy_pattern;

public class SchoolGirls {
    private String name;
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
}
```

```java
package proxy_pattern;
//test，即客户端
public class test {
    public static void main(String[] args) throws Exception {
        SchoolGirls mm=new SchoolGirls();
        mm.setName("jiaojiao");
        Proxy daili=new Proxy(mm);
        daili.Give_Chocolate();
        daili.Give_Dolls();
    }
}
```

